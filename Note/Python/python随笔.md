## 1.赋值，浅拷贝，深拷贝，参数传递
### 赋值
> python中的"="号，会为每个出现的对象进行`赋值`（*无论是可变还是不可变类型，开辟新的内存空间保存对象的值，并将地址传递给"="左侧的变量*），哪怕它们的值是一样的，但是当数值比较小或者字符串长度较短的时候，为了节省内存空间，相同大小的两个变量可能会因用户相同的地址中的数值。具体详细可参考上述博客。参考:
1. https://mp.weixin.qq.com/s?__biz=MjM5MDEyMDk4Mw==&mid=2650168761&idx=1&sn=e2f9f496fa37e4866edbe5e46617cc1f&chksm=be4b50c1893cd9d7abb9b1ef7e10e6e0726ee0a665c088219af665cbb5b0932a92820ece6f7f&mpshare=1&scene=1&srcid=&sharer_sharetime=1567247006723&sharer_shareid=b70fc7d4e5a767ab8b0b215a2350694c#rd
2. https://my.oschina.net/leejun2005/blog/145911


> 在这之前需要讨论一下不可变类型和可变类型,不可变类型就是指值的不可变。一旦改变不可变类型的值，就会创建一个新的地址装新的值，并将地址赋值给该不可变类型变量，旧值可能因为没有被引用而被垃圾回收。另外，不可变的类型可以计算hash值，作为字典的key。可变类型数据对对象操作(此处的操作不是赋值)的时候，不需要再在其他地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它的内存地址会保持不变，但区域会变长或者变短。
> - 不可变类型：数字，元组，字符串
> - 可变类型：列表，集合，字典


> id(a)可以获得a所指对象的地址，a也就是数字0的指针，a中里面封装的是地址，而不是指针a自己的地址。
```python
In [1]: a=0
In [2]: id(a)
Out[2]: 1460666832
```

下面来看赋值：a=b，即为将a所指对象的地址复制一份给b，b便也指向了这个对象。

参考：https://blog.csdn.net/weixin_37887248/article/details/81565815

python中的"="号，会为每个出现的对象进行`赋值`（*无论是可变还是不可变类型，开辟新的内存空间保存对象的值，并将地址传递给"="左侧的变量*），哪怕它们的值是一样的，但是当数值比较小或者字符串长度较短的时候，为了节省内存空间，相同大小的两个变量可能会因用户相同的地址中的数值。具体详细可参考上述博客。![](https://raw.githubusercontent.com/Raymond0225/picbed/master/img/20190829224922.png)
- 不可变类型的赋值

```python
x=500
y=x
y="hello"
```
1. x=500

python会创建一个PyInt大小的的内存pos1来存储数值500，然后python再命名x指向了这一块内存，注意此时内存中存储的是不可变类型，用下表表示
|内存名称|对应内存|
|----|----|
|x:pos1|pos1:PyInt(500)不可变|
2. y=x

此时x是一个变量，是一个内存的“标签”，相当于该内存地址，意味将x对该内存的引用复制一份给了y，y也指向了该地址。
|内存名称|对应内存|
|:----:|:----:|
|x:pos1,y:pos1|pos1:PyInt(500)不可变|

*由于我不会弄这个表格，所以只能自行查看上述博客*

### 浅复制和深复制
理解上述博客所讲的内容后，接下来就容易很多
1. 可变类型浅拷贝
```python
import copy
a=[1,2]
b=[3,4]
c=[a,b]
d=c
e=copy.copy(c) # copy.copy是浅拷贝
```
针对于上述代码，用下面这张图来解释

![](https://raw.githubusercontent.com/Raymond0225/picbed/master/img/20190830002710.png)
对于图中的数组[1,2],[3,4]来说，也是可以展开成c,d,e这样的图，但是这里为了方便表示，就没没有展开，其中c和d的所指向的内存地址是一样的，但是e的内存地址是不一样的，即为id(c)=id(d)≠id(e)
2. 可变类型深拷贝
```python
import copy
a=[1,2]
b=[3,4]
c=[a,b]
d=c
e=copy.deepcopy(c) # copy.copy是浅拷贝
```
针对于上述代码，用下面这张图来解释
![](https://raw.githubusercontent.com/Raymond0225/picbed/master/img/20190830005644.png)

3. 不可变类型的浅深拷贝

由于不可类型的值不允许改变，一旦改变就会重新建立一个新的内存空间，故不可改变类型的浅深拷贝没有意义，如果非要进行浅深拷贝，则b=a和b=copy.copy(a)和b=copy.deepcoy(a)三者等价。但是值得一提的是，如果a=([1,2],[3,4]),对于a的浅拷贝此时依然是简单的变量的赋值操作，但是深拷贝的话此时就相当于像是对可变类型的深拷贝了，即为一旦不可变类型中含有一个可变类型元素，深拷贝将会遍历该不可变类型中的所有元素进行拷贝。
### 参数传递
由上面参考文献可知：**Python 里的参数是通过赋值传递的**
```python
def f(x):
    x=3
a=1
f(a)
print(a)
********************
out:1
```
调用方法f的时候，传参的时候是通过赋值传递的，即为`x=a`，x就指向了1，但是x的作用域被局限在方法f中。当在函数内部将x赋值为3的时候，x重新指向了对象3，与之前的1不在有关系，同理和a也不再有关系了，所以外部的a不会有任何变化,同理，对于可变类型也是如此。
```python
def f(x):
    x=[2,3]
a=[1,2]
f(a)
print(a)
********************
out:[1, 2]
```

## 方法的缺省参数
*args会存放所有未命名的变量参数，args为元组，而**的变量kwargs会存放命名参数，即为形如key=value的参数，kwargs为字典

> 黑马教程

## global参数

仔细想想，就会发现不止dict不需要global，所有”明确的“东西都不需要global。因为int类型str类型之类的不可变对象，每一次操作就重建新的对象，他们只有一种修改方法，即x = y， 恰好这种修改方法同时也是创建变量的方法，所以产生了歧义，不知道是要修改还是创建。而dict/list/对象等可变对象，操作不会重建对象，可以通过dict['x']=y或list.append()之类的来修改，跟创建变量不冲突，不产生歧义，所以都不用显式global。

> csdn.python

## 编码与解码

将字符串转化为二进制码是编码，将二进制码转为字符串是解码